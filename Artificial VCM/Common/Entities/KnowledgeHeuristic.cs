using System;
using System.Collections.Generic;
using System.Linq;

namespace Common.Entities
{
    using Environments;
    using Helpers;

    public class KnowledgeHeuristic : ICloneable<KnowledgeHeuristic>, IEquatable<KnowledgeHeuristic>
    {
        public KnowledgeHeuristicsLayer Layer { get; set; }

        
        /// <summary>
        /// Set in configuration json only
        /// </summary>
        public int MentalModel { get; private set; }

        /// <summary>
        /// Set in configuration json only
        /// </summary>
        public int KnowledgeHeuristicsLayer { get; private set; }


        public int PositionNumber { get; set; }

        public KnowledgeHeuristicAntecedentPart[] Antecedent { get; private set; }

        public KnowledgeHeuristicConsequent Consequent { get; private set; }

        public bool IsAction { get; private set; }

        public bool IsModifiable { get; private set; }

        public int RequiredParticipants { get; private set; }

        public bool AutoGenerated { get; private set; }

        public bool IsCollectiveAction
        {
            get
            {
                return RequiredParticipants > 1 || RequiredParticipants == 0;
            }
        }


        public string Id
        {
            get
            {
                return string.Format("MM{0}_L{1}_KH{2}", Layer.Set.PositionNumber, Layer.PositionNumber, PositionNumber);
            }
        }

        /// <summary>
        /// Checks agent variables on antecedent conditions
        /// </summary>
        /// <param name="agent"></param>
        /// <returns></returns>   
        public bool IsMatch(IAgent agent)
        {
            return Antecedent.All(a => a.IsMatch(agent));
        }


        /// <summary>
        /// Applies the heuristic. Copies consequent value or reference variable value to agent variables
        /// </summary>
        /// <param name="agent"></param>
        /// <returns></returns>
        public TakenAction Apply(IAgent agent)
        {
            dynamic value;

            if (string.IsNullOrEmpty(Consequent.VariableValue) == false)
            {
                value = agent[Consequent.VariableValue];
            }
            else
            {
                value = Consequent.Value;
            }


            if (Consequent.SavePrevious)
            {
                string key = string.Format("{0}_{1}", SosielVariables.PreviousPrefix, Consequent.Param);

                agent[key] = agent[Consequent.Param];

                if (Consequent.CopyToCommon)
                {
                    agent.SetToCommon(string.Format("{0}_{1}_{2}", SosielVariables.AgentPrefix, agent.Id, key), agent[Consequent.Param]);
                }
            }

            if (Consequent.CopyToCommon)
            {
                string key = string.Format("{0}_{1}_{2}", SosielVariables.AgentPrefix, agent.Id, Consequent.Param);

                agent.SetToCommon(key, value);
            }

            agent[Consequent.Param] = value;


            agent.KnowledgeHeuristicActivationFreshness[this] = 0;

            return new TakenAction(Id, Consequent.Param, value);
        }

        /// <summary>
        /// Creates new heuristic with passed parameters 
        /// </summary>
        /// <param name="antecedent"></param>
        /// <param name="consequent"></param>
        /// <returns></returns>
        public static KnowledgeHeuristic Create(KnowledgeHeuristicAntecedentPart[] antecedent, KnowledgeHeuristicConsequent consequent, bool isAction, bool isModifable, int requiredParticipants, bool autoGenerated = false)
        {
            KnowledgeHeuristic knowledgeHeuristic = new KnowledgeHeuristic();

            knowledgeHeuristic.Antecedent = antecedent;
            knowledgeHeuristic.Consequent = consequent;
            knowledgeHeuristic.IsAction = isAction;
            knowledgeHeuristic.IsModifiable = isModifable;
            knowledgeHeuristic.RequiredParticipants = requiredParticipants;
            knowledgeHeuristic.AutoGenerated = autoGenerated;

            return knowledgeHeuristic;
        }

        /// <summary>
        /// Creates shallow object copy 
        /// </summary>
        /// <returns></returns>
        public KnowledgeHeuristic Clone()
        {
            return (KnowledgeHeuristic)this.MemberwiseClone();
        }



        /// <summary>
        /// Creates heuristic copy but replaces antecedent parts and consequent by new values. 
        /// </summary>
        /// <param name="old"></param>
        /// <param name="newValue"></param>
        /// <returns></returns>
        public static KnowledgeHeuristic Renew(KnowledgeHeuristic old, KnowledgeHeuristicAntecedentPart[] newAntecedent, KnowledgeHeuristicConsequent newConsequent)
        {
            KnowledgeHeuristic heuristic = old.Clone();

            heuristic.Antecedent = newAntecedent;
            heuristic.Consequent = newConsequent;

            return heuristic;
        }

        /// <summary>
        /// Compares two heuristic objects
        /// </summary>
        /// <param name="other"></param>
        /// <returns></returns>
        public bool Equals(KnowledgeHeuristic other)
        {
            //check on reference equality first
            //custom logic for comparing two objects
            return ReferenceEquals(this, other) 
                || (other != null && Consequent == other.Consequent && Antecedent.Length == other.Antecedent.Length && Antecedent.All(ant => other.Antecedent.Any(ant2 => ant == ant2)));
        }

        public override bool Equals(object obj)
        {
            //check on reference equality first
            return base.Equals(obj) || Equals(obj as KnowledgeHeuristic);
        }

        public override int GetHashCode()
        {
            //disable comparing by hash code
            return 0;
        }

        public static bool operator ==(KnowledgeHeuristic a, KnowledgeHeuristic b)
        {
            if (Object.ReferenceEquals(a, b))
            {
                return true;
            }

            // If one is null, but not both, return false.
            if (((object)a == null) || ((object)b == null))
            {
                return false;
            }

            return a.Equals(b);
        }

        public static bool operator !=(KnowledgeHeuristic a, KnowledgeHeuristic b)
        {
            return !(a == b);
        }

        public override string ToString()
        {
            return Id;
        }
    }
}
